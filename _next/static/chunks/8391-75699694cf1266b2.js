"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[8391],{68391:(t,e,a)=>{a.d(e,{G:()=>tu});var n=a(26715),r=a(926),s=a(67622);async function i(t,{chain:e}){let{id:a,name:n,nativeCurrency:r,rpcUrls:i,blockExplorers:o}=e;await t.request({method:"wallet_addEthereumChain",params:[{chainId:(0,s.cK)(a),chainName:n,nativeCurrency:r,rpcUrls:i.default.http,blockExplorerUrls:o?Object.values(o).map(({url:t})=>t):void 0}]},{dedupe:!0,retryCount:0})}var o=a(20760),c=a(98564),u=a(35883);async function l(t){return t.account?.type==="local"?[t.account.address]:(await t.request({method:"eth_accounts"},{dedupe:!0})).map(t=>(0,u.o)(t))}var d=a(93727),h=a(54335),m=a(27493),p=a(35886),w=a(19405),f=a(50431),v=a(7441),g=a(81379),y=a(60367),C=a(79731),T=a(5112);let b="0x5792579257925792579257925792579257925792579257925792579257925792",q=(0,s.cK)(0,{size:32});async function I(t,e){let{account:a=t.account,capabilities:n,chain:r=t.chain,experimental_fallback:i,experimental_fallbackDelay:o=32,forceAtomic:u=!1,id:l,version:d="2.0.0"}=e;if(void 0===a)throw new f.T({docsPath:"/docs/actions/wallet/sendCalls"});let h=a?(0,w.J)(a):null,p=e.calls.map(t=>({data:t.abi?(0,y.p)({abi:t.abi,functionName:t.functionName,args:t.args}):t.data,to:t.to,value:t.value?(0,s.cK)(t.value):void 0}));try{let e=await t.request({method:"wallet_sendCalls",params:[{atomicRequired:u,calls:p,capabilities:n,chainId:(0,s.cK)(r.id),from:h?.address,id:l,version:d}]},{retryCount:0});if("string"==typeof e)return{id:e};return e}catch(a){if(i&&("MethodNotFoundRpcError"===a.name||"MethodNotSupportedRpcError"===a.name||a.details.toLowerCase().includes("does not exist / is not available")||a.details.toLowerCase().includes("missing or invalid. request()")||a.details.toLowerCase().includes("did not match any variant of untagged enum"))){if(n&&Object.values(n).some(t=>!t.optional)){let t="non-optional `capabilities` are not supported on fallback to `eth_sendTransaction`.";throw new g.L5(new v.C(t,{details:t}))}if(u&&p.length>1){let t="`forceAtomic` is not supported on fallback to `eth_sendTransaction`.";throw new g.jz(new v.C(t,{details:t}))}let e=[];for(let a of p){let n=(0,c.v)(t,{account:h,chain:r,data:a.data,to:a.to,value:a.value?(0,m.uU)(a.value):void 0});e.push(n),o>0&&await new Promise(t=>setTimeout(t,o))}let a=await Promise.allSettled(e);if(a.every(t=>"rejected"===t.status))throw a[0].reason;let i=a.map(t=>"fulfilled"===t.status?t.value:q);return{id:(0,C.xW)([...i,(0,s.cK)(r.id,{size:32}),b])}}throw(0,T.p)(a,{...e,account:h,chain:e.chain})}}async function _(t,e){async function a(e){if(e.endsWith(b.slice(2))){let a=(0,h.B)((0,d.iN)(e,-64,-32)),n=(0,d.iN)(e,0,-64).slice(2).match(/.{1,64}/g),r=await Promise.all(n.map(e=>q.slice(2)!==e?t.request({method:"eth_getTransactionReceipt",params:[`0x${e}`]},{dedupe:!0}):void 0)),s=r.some(t=>null===t)?100:r.every(t=>t?.status==="0x1")?200:r.every(t=>t?.status==="0x0")?500:600;return{atomic:!1,chainId:(0,m.ME)(a),receipts:r.filter(Boolean),status:s,version:"2.0.0"}}return t.request({method:"wallet_getCallsStatus",params:[e]})}let{atomic:n=!1,chainId:r,receipts:s,version:i="2.0.0",...o}=await a(e.id),[c,u]=(()=>{let t=o.status;return t>=100&&t<200?["pending",t]:t>=200&&t<300?["success",t]:t>=300&&t<700?["failure",t]:"CONFIRMED"===t?["success",200]:"PENDING"===t?["pending",100]:[void 0,t]})();return{...o,atomic:n,chainId:r?(0,m.ME)(r):void 0,receipts:s?.map(t=>({...t,blockNumber:m.uU(t.blockNumber),gasUsed:m.uU(t.gasUsed),status:p.Lj[t.status]}))??[],statusCode:u,status:c,version:i}}async function A(t,e={}){let{account:a=t.account,chainId:n}=e,r=a?(0,w.J)(a):void 0,i=n?[r?.address,[(0,s.cK)(n)]]:[r?.address],o=await t.request({method:"wallet_getCapabilities",params:i}),c={};for(let[t,e]of Object.entries(o))for(let[a,n]of(c[Number(t)]={},Object.entries(e)))"addSubAccount"===a&&(a="unstable_addSubAccount"),c[Number(t)][a]=n;return"number"==typeof n?c[n]:c}async function N(t){return await t.request({method:"wallet_getPermissions"},{dedupe:!0})}var P=a(17255),E=a(34524),x=a(13649);async function z(t,e){let{account:a=t.account,chainId:n,nonce:s}=e;if(!a)throw new f.T({docsPath:"/docs/eip7702/prepareAuthorization"});let i=(0,w.J)(a),o=(()=>{if(e.executor)return"self"===e.executor?e.executor:(0,w.J)(e.executor)})(),c={address:e.contractAddress??e.address,chainId:n,nonce:s};return void 0===c.chainId&&(c.chainId=t.chain?.id??await (0,E.T)(t,r.T,"getChainId")({})),void 0===c.nonce&&(c.nonce=await (0,E.T)(t,x.y,"getTransactionCount")({address:i.address,blockTag:"pending"}),("self"===o||o?.address&&(0,P.h)(o.address,i.address))&&(c.nonce+=1)),c}var S=a(71535);async function k(t){return(await t.request({method:"eth_requestAccounts"},{dedupe:!0,retryCount:0})).map(t=>(0,u.b)(t))}async function K(t,e){return t.request({method:"wallet_requestPermissions",params:[e]},{retryCount:0})}var R=a(2806);async function U(t,e){let{id:a}=e;await t.request({method:"wallet_showCallsStatus",params:[a]})}async function j(t,e){let{account:a=t.account}=e;if(!a)throw new f.T({docsPath:"/docs/eip7702/signAuthorization"});let n=(0,w.J)(a);if(!n.signAuthorization)throw new f.Z({docsPath:"/docs/eip7702/signAuthorization",metaMessages:["The `signAuthorization` Action does not support JSON-RPC Accounts."],type:n.type});let r=await z(t,e);return n.signAuthorization(r)}var O=a(41246),D=a(1196),F=a(76743),J=a(84062);async function L(t,e){let{account:a=t.account,chain:n=t.chain,...i}=e;if(!a)throw new f.T({docsPath:"/docs/actions/wallet/signTransaction"});let o=(0,w.J)(a);(0,J.c)({account:o,...e});let c=await (0,E.T)(t,r.T,"getChainId")({});null!==n&&(0,D.v)({currentChainId:c,chain:n});let u=n?.formatters||t.chain?.formatters,l=u?.transactionRequest?.format||F.Bv;return o.signTransaction?o.signTransaction({...i,chainId:c},{serializer:t.chain?.serializers?.transaction}):await t.request({method:"eth_signTransaction",params:[{...l(i),chainId:(0,s.cK)(c),from:o.address}]},{retryCount:0})}var M=a(90477);async function B(t,e){let{account:a=t.account,domain:n,message:r,primaryType:s}=e;if(!a)throw new f.T({docsPath:"/docs/actions/wallet/signTypedData"});let i=(0,w.J)(a),o={EIP712Domain:(0,M.H4)({domain:n}),...e.types};if((0,M.$$)({domain:n,message:r,primaryType:s,types:o}),i.signTypedData)return i.signTypedData({domain:n,message:r,primaryType:s,types:o});let c=(0,M.v8)({domain:n,message:r,primaryType:s,types:o});return t.request({method:"eth_signTypedData_v4",params:[i.address,c]},{retryCount:0})}async function $(t,{id:e}){await t.request({method:"wallet_switchEthereumChain",params:[{chainId:(0,s.cK)(e)}]},{retryCount:0})}var W=a(72342),G=a(86435),Q=a(62739),Y=a(79183);async function H(t,e){let a;let{id:n,pollingInterval:r=t.pollingInterval,status:s=({statusCode:t})=>t>=200,timeout:i=6e4}=e,o=(0,Y.A)(["waitForCallsStatus",t.uid,n]),{promise:c,resolve:u,reject:l}=(0,Q.Y)(),d=(0,W.lB)(o,{resolve:u,reject:l},e=>{let i=(0,G.w)(async()=>{let r=t=>{clearTimeout(a),i(),t(),d()};try{let a=await _(t,{id:n});if(!s(a))return;r(()=>e.resolve(a))}catch(t){r(()=>e.reject(t))}},{interval:r,emitOnBegin:!0});return i});return a=i?setTimeout(()=>{d(),clearTimeout(a),l(new V({id:n}))},i):void 0,await c}class V extends v.C{constructor({id:t}){super(`Timed out while waiting for call bundle with id "${t}" to be confirmed.`,{name:"WaitForCallsStatusTimeoutError"})}}async function Z(t,e){return await t.request({method:"wallet_watchAsset",params:e},{retryCount:0})}var X=a(61131);function tt(t){return{addChain:e=>i(t,e),deployContract:e=>(function(t,e){let{abi:a,args:n,bytecode:r,...s}=e,i=(0,o.m)({abi:a,args:n,bytecode:r});return(0,c.v)(t,{...s,...s.authorizationList?{to:null}:{},data:i})})(t,e),getAddresses:()=>l(t),getCallsStatus:e=>_(t,e),getCapabilities:e=>A(t,e),getChainId:()=>(0,r.T)(t),getPermissions:()=>N(t),prepareAuthorization:e=>z(t,e),prepareTransactionRequest:e=>(0,S.ft)(t,e),requestAddresses:()=>k(t),requestPermissions:e=>K(t,e),sendCalls:e=>I(t,e),sendRawTransaction:e=>(0,R.L)(t,e),sendTransaction:e=>(0,c.v)(t,e),showCallsStatus:e=>U(t,e),signAuthorization:e=>j(t,e),signMessage:e=>(0,O.l)(t,e),signTransaction:e=>L(t,e),signTypedData:e=>B(t,e),switchChain:e=>$(t,e),waitForCallsStatus:e=>H(t,e),watchAsset:e=>Z(t,e),writeContract:e=>(0,X.E)(t,e)}}var te=a(95990);async function ta(t,e={}){return(await (0,te.r)(t,e)).extend(tt)}var tn=a(62108),tr=a(12115),ts=a(43484),ti=a(2145),to=a(18224),tc=a(53031);function tu(){var t,e,a,r;let s=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{query:i={},...o}=s,c=(0,tc.U)(o),u=(0,n.jE)(),{address:l,connector:d,status:h}=(0,ti.F)({config:c}),m=(0,to.i)({config:c}),p=null!==(t=s.connector)&&void 0!==t?t:d,{queryKey:w,...f}=function(t,e={}){return{gcTime:0,async queryFn({queryKey:a}){let{connector:n}=e,{connectorUid:r,scopeKey:s,...i}=a[1];return ta(t,{...i,connector:n})},queryKey:function(t={}){let{connector:e,...a}=t;return["walletClient",{...(0,tn.xO)(a),connectorUid:e?.uid}]}(e)}}(c,{...s,chainId:null!==(e=s.chainId)&&void 0!==e?e:m,connector:null!==(a=s.connector)&&void 0!==a?a:d}),v=!!(("connected"===h||"reconnecting"===h&&(null==p?void 0:p.getProvider))&&(null===(r=i.enabled)||void 0===r||r)),g=(0,tr.useRef)(l);return(0,tr.useEffect)(()=>{let t=g.current;!l&&t?(u.removeQueries({queryKey:w}),g.current=void 0):l!==t&&(u.invalidateQueries({queryKey:w}),g.current=l)},[l,u]),(0,ts.IT)({...i,...f,queryKey:w,enabled:v,staleTime:Number.POSITIVE_INFINITY})}}}]);